class XsbugConnection extends WebSocket {
	constructor(uri) {
		super(uri, "x-xsbug");

		super.onopen = this.onopen;
		super.onclose = this.onclose;
		super.onerror = this.onerror;
		super.onmessage = this.onmessage;

		super.binaryType = "arraybuffer";

		this.requestID = 1;
		this.pending = [];
	}
	onopen() {
		console.log("WS OPEN");
	}
	onclose() {
		console.log("WS CLOSE");
	}
	onerror() {
		console.log("WS ERROR");
	}
	onmessage(event) {
		console.log("WS RECEIVE " + event.data);

		if ("string" === typeof event.data) {
			const msg = new XsbugMessage((new DOMParser).parseFromString(event.data, "application/xml"));
			if (msg.break)
				this.onBreak(msg);
			else if (msg.login)
				this.onLogin(msg);
			else if (msg.instruments)
				this.onInstrumentationConfigure(msg);
			else if (msg.local)
				this.onLocal(msg);
			else if (msg.log)
				this.onLog(msg);
			else if (msg.samples)
				this.onInstrumentationSamples(msg);
			else
				debugger;		// unhandled
		}
		else {
			const data = new DataView(event.data);
			switch (data.getUint8(0)) {
				case 5:
					const id = data.getUint16(1), code = data.getInt16(3);
					const index = this.pending.findIndex(pending => id === pending.id)
					if (index >= 0) {
						const pending = this.pending[index];
						this.pending.splice(index, 1);
						(pending.callback)(id, code, event.data.slice(5));
					}
					break;
				default:
					debugger;
					break;
			}
		}
	}
	send(data) {
		console.log("WS SEND " + data);
		return super.send(data);
	}

	// transmit xsbug message
	doClearBreakpoint(path, line) {
		this.sendCommand(`<clear-breakpoint path="${path}" line="${line}"/>`);
	}
	doGo() {
		this.sendCommand("<go/>");
	}
	doScript(msg) {
		this.sendCommand(`<script><![CDATA[${msg}]]></script>`);
	}
	doSetBreakpoint(path, line) {
		this.sendCommand(`<set-breakpoint path="${path}" line="${line}"/>`);
	}
	doSelect(value) {
		this.sendCommand(`<select id="${value}"/>`);
	}
	doSetAllBreakpoints(breakpoints = [], exceptions = true, start = false) {
		breakpoints = breakpoints.map(b => `<breakpoint path="${b.path}" line="${b.line}"/>`);
		if (exceptions)
			breakpoints.unshift('<breakpoint path="exceptions" line="0"/>')
		if (start)
			breakpoints.unshift('<breakpoint path="start" line="0"/>')
		this.sendCommand(`<set-all-breakpoints>${breakpoints.join("")}</set-all-breakpoints>`);
	}
	doStep() {
		this.sendCommand("<step/>");
	}
	doStepInside() {
		this.sendCommand("<step-inside/>");
	}
	doStepOutside() {
		this.sendCommand("<step-outside/>");
	}
	doToggle(value) {
		this.sendCommand(`<toggle id="${value}"/>`);
	}

	// transmit host messages
	doGetPreference(domain, key, callback) {
		const byteLength = domain.length + 1 + key.length + 1;
		const payload = new Uint8Array(byteLength);
		let j = 0;
		for (let i = 0; i < domain.length; i++)
			payload[j++] = domain.charCodeAt(i)
		j++;
		for (let i = 0; i < key.length; i++)
			payload[j++] =  key.charCodeAt(i);

		this.sendBinaryCommand(6, payload, callback);
	}
	doInstall(offset, data) {
		const max = 512;
		for (let i = 0; i < data.byteLength; i += max, offset += max) {
			const use = Math.min(max, data.byteLength - i);
			const payload = new Uint8Array(4 + use);
			payload[0] = (offset >> 24) & 0xff;
			payload[1] = (offset >> 16) & 0xff;
			payload[2] = (offset >>  8) & 0xff;
			payload[3] =  offset        & 0xff;
			payload.set(new Uint8Array(data, i, use), 4);

			this.sendBinaryCommand(3, payload);
		}
	}
	doRestart() {
		this.sendBinaryCommand(1);
	}
	doSetPreference(domain, key, value) {		// assumes 7 bit ASCII values
		const byteLength = domain.length + 1 + key.length + 1 + value.length + 1;
		const payload = new Uint8Array(byteLength);
		let j = 0;
		for (let i = 0; i < domain.length; i++)
			payload[j++] = domain.charCodeAt(i)
		j++;
		for (let i = 0; i < key.length; i++)
			payload[j++] =  key.charCodeAt(i)
		j++;
		for (let i = 0; i < value.length; i++)
			payload[j++] = value.charCodeAt(i)

		this.sendBinaryCommand(4, payload);
	}
	doUninstall(callback) {
		this.sendBinaryCommand(2, undefined, callback);
	}

	// receive messages
	onBreak(msg) {}
	onLogin(msg) {}
	onInstrumentationConfigure(msg) {}
	onInstrumentationSamples(msg) {}
	onLocal(msg) {}
	onLog(msg) {}

	// helpers
	sendCommand(msg) {
		this.send(XsbugConnection.crlf + msg + XsbugConnection.crlf);
	}
	sendBinaryCommand(command, payload, callback) {
		if (payload) {
			if (!(payload instanceof ArrayBuffer))
				payload = payload.buffer;
		}
		let needed = 1;
		if (payload)
			needed += 2 + payload.byteLength;
		else if (callback)
			needed += 2;
		const msg = new Uint8Array(needed);
		msg[0] = command;
		if (callback) {
			msg[1] = this.requestID >> 8;
			msg[2] = this.requestID & 0xff;
			this.pending.push({callback, id: this.requestID++});
		}
		if (payload)
			msg.set(new Uint8Array(payload), 3);
		this.send(msg.buffer);
	}
}
XsbugConnection.crlf = String.fromCharCode(13) + String.fromCharCode(10);

class XsbugMessage {
	constructor(xml) {
		xml = xml.documentElement;
		if ("xsbug" !== xml.nodeName)
			throw new Error("not xsbug xml");
		for (let node = xml.firstChild; node; node = node.nextSibling) {
			XsbugMessage[node.nodeName](this, node);
		}
		return;
	}

	// node parsers
	static login(message, node) {
		message.login = {
			name: node.attributes.name.value,
			value: node.attributes.value.value,
		};
	}
	static samples(message, node) {
		message.samples = node.textContent.split(",").map(value => parseInt(value));
	}
	static frames(message, node) {
		message.frames = [];
		for (node = node.firstChild; node; node = node.nextSibling)
			message.frames.push(XsbugMessage.oneFrame(node));
	}
	static local(message, node) {
		const local = XsbugMessage.oneFrame(node);
		local.properties = [];
		for (node = node.firstChild; node; node = node.nextSibling)
			local.properties.push(XsbugMessage.oneProperty(node));
		message.local = local;
	}
	static global(message, node) {
		message.global = [];
		for (node = node.firstChild; node; node = node.nextSibling)
			message.global.push(XsbugMessage.oneProperty(node));
		message.global.sort((a, b) => a.name.localeCompare(b.name));
	}
	static grammar(message, node) {
		message.module = [];
		for (node = node.firstChild; node; node = node.nextSibling)
			message.module.push(XsbugMessage.oneProperty(node));

		message.module.sort((a, b) => a.name.localeCompare(b.name));
	}
	static break(message, node) {
		message.break = {
			path: node.attributes.path.value,
			line: parseInt(node.attributes.line.value),
			message: node.textContent,
		};
	}
	static log(message, node) {
		message.log = node.textContent;
	}
	static instruments(message, node) {
		message.instruments = [];
		for (node = node.firstChild; node; node = node.nextSibling) {
			message.instruments.push({
				name: node.attributes.name.value,
				value: node.attributes.value.value,
			});
		}
	}

	// helpers
	static oneFrame(node) {
		const frame = {
			name: node.attributes.name.value,
			value: node.attributes.value.value,
		};
		if (node.attributes.path) {
			frame.path = node.attributes.path.value;
			frame.line = parseInt(node.attributes.line.value);
		}
		return frame;
	}
	static oneProperty(node) {
		const flags = node.attributes.flags.value;
		const property = {
			name: node.attributes.name.value,
			flags: {
				value: flags,
				delete: flags.indexOf("C") < 0,
				enum: flags.indexOf("E") < 0,
				set: flags.indexOf("W") < 0,
			},
		};
		if (node.attributes.value)
			property.value = node.attributes.value.value;

		if (node.firstChild) {
			property.property = [];
			for (let p = node.firstChild; p; p = p.nextSibling)
				property.property.push(XsbugMessage.oneProperty(p))
			property.property.sort((a, b) => a.name.localeCompare(b.name));
		}

		return property;
	}
}

const httpGetXSA = Uint8Array.of(0x00, 0x00, 0x01, 0xF2, 0x58, 0x53, 0x5F, 0x41, 0x00, 0x00, 0x00, 0x0C, 0x56, 0x45, 0x52, 0x53, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x53, 0x49, 0x47, 0x4E, 0x26, 0x3B, 0x7F, 0x80, 0x47, 0x45, 0x8C, 0x6A, 0x09, 0x84, 0x18, 0x27, 0x43, 0x30, 0x81, 0x75, 0x00, 0x00, 0x00, 0x18, 0x43, 0x48, 0x4B, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87, 0x53, 0x59, 0x4D, 0x42, 0x0C, 0x00, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x00, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x00, 0x53, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x00, 0x72, 0x65, 0x73, 0x70, 0x6F, 0x6E, 0x73, 0x65, 0x00, 0x65, 0x74, 0x63, 0x00, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x00, 0x74, 0x72, 0x61, 0x63, 0x65, 0x00, 0x70, 0x61, 0x74, 0x68, 0x00, 0x68, 0x6F, 0x73, 0x74, 0x00, 0x63, 0x61, 0x6C, 0x6C, 0x62, 0x61, 0x63, 0x6B, 0x00, 0x6D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x00, 0x2F, 0x55, 0x73, 0x65, 0x72, 0x73, 0x2F, 0x68, 0x6F, 0x64, 0x64, 0x69, 0x65, 0x2F, 0x50, 0x72, 0x6F, 0x6A, 0x65, 0x63, 0x74, 0x73, 0x2F, 0x72, 0x75, 0x6E, 0x6D, 0x6F, 0x64, 0x2F, 0x6D, 0x6F, 0x64, 0x73, 0x2F, 0x68, 0x74, 0x74, 0x70, 0x67, 0x65, 0x74, 0x2F, 0x6D, 0x6F, 0x64, 0x2E, 0x6A, 0x73, 0x00, 0x00, 0x00, 0x01, 0x1F, 0x4D, 0x4F, 0x44, 0x53, 0x00, 0x00, 0x00, 0x10, 0x50, 0x41, 0x54, 0x48, 0x6D, 0x6F, 0x64, 0x2E, 0x78, 0x73, 0x62, 0x00, 0x00, 0x00, 0x01, 0x07, 0x43, 0x4F, 0x44, 0x45, 0x4A, 0x0B, 0x80, 0x6B, 0x0F, 0x00, 0x4E, 0x0B, 0x80, 0x2C, 0xD1, 0x00, 0x0C, 0x00, 0x89, 0x03, 0x91, 0x02, 0x4A, 0x0B, 0x80, 0x6B, 0x11, 0x00, 0xAB, 0x15, 0x6D, 0x61, 0x6B, 0x69, 0x6E, 0x67, 0x20, 0x68, 0x74, 0x74, 0x70, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x0A, 0x00, 0x60, 0x01, 0xBC, 0x80, 0x06, 0x80, 0x59, 0x06, 0x80, 0x21, 0x7E, 0x6B, 0x13, 0x00, 0x77, 0x7C, 0x98, 0x04, 0x52, 0x04, 0xB0, 0x08, 0x80, 0x09, 0xAB, 0x10, 0x77, 0x77, 0x77, 0x2E, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x2E, 0x63, 0x6F, 0x6D, 0x00, 0x76, 0x00, 0x52, 0x04, 0xB0, 0x07, 0x80, 0x09, 0xAB, 0x02, 0x2F, 0x00, 0x76, 0x00, 0x52, 0x04, 0xB0, 0x03, 0x80, 0x09, 0x80, 0x02, 0x80, 0x59, 0x02, 0x80, 0x76, 0x00, 0xBE, 0x01, 0x60, 0x01, 0x50, 0x02, 0x73, 0x67, 0x03, 0x7E, 0x6B, 0x14, 0x00, 0x50, 0x03, 0x32, 0xFF, 0xFF, 0x2B, 0x4F, 0x0C, 0x03, 0x89, 0x03, 0x75, 0x0A, 0x80, 0x75, 0x05, 0x80, 0x75, 0x04, 0x80, 0x4A, 0x0B, 0x80, 0x6B, 0x14, 0x00, 0x02, 0x00, 0xC2, 0x02, 0x7E, 0x02, 0x01, 0xC2, 0x03, 0x7E, 0x02, 0x02, 0xC2, 0x04, 0x7E, 0x6B, 0x16, 0x00, 0x60, 0x05, 0x52, 0x02, 0x42, 0x18, 0x22, 0x6B, 0x17, 0x00, 0x52, 0x03, 0x60, 0x01, 0xBC, 0x80, 0x06, 0x80, 0x59, 0x06, 0x80, 0x21, 0x7E, 0x6B, 0x18, 0x00, 0xAB, 0x02, 0x0A, 0x00, 0x60, 0x01, 0xBC, 0x80, 0x06, 0x80, 0x59, 0x06, 0x80, 0x21, 0x7E, 0x3D, 0x9A, 0x09, 0x80, 0x7E, 0x3D, 0x41, 0x7E, 0xB0, 0x00, 0x80, 0x6B, 0x0F, 0x00, 0xAB, 0x05, 0x68, 0x74, 0x74, 0x70, 0x00, 0xB0, 0x00, 0x80, 0x60, 0x03, 0xB8, 0xB0, 0x01, 0x80, 0x7A, 0x7A, 0x60, 0x03, 0xB8, 0x60, 0x03, 0x6D, 0x8F, 0x3D, 0x00, 0x00, 0x00, 0x08, 0x52, 0x53, 0x52, 0x43).buffer;
const helloWorldXSA = Uint8Array.of(0x00, 0x00, 0x01, 0x21, 0x58, 0x53, 0x5F, 0x41, 0x00, 0x00, 0x00, 0x0C, 0x56, 0x45, 0x52, 0x53, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x53, 0x49, 0x47, 0x4E, 0xD1, 0x5D, 0x57, 0xB6, 0xA9, 0x5C, 0xFB, 0x6E, 0x4F, 0x23, 0xD6, 0x88, 0x96, 0xA0, 0x15, 0xDE, 0x00, 0x00, 0x00, 0x18, 0x43, 0x48, 0x4B, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x53, 0x59, 0x4D, 0x42, 0x03, 0x00, 0x78, 0x00, 0x2F, 0x55, 0x73, 0x65, 0x72, 0x73, 0x2F, 0x68, 0x6F, 0x64, 0x64, 0x69, 0x65, 0x2F, 0x50, 0x72, 0x6F, 0x6A, 0x65, 0x63, 0x74, 0x73, 0x2F, 0x72, 0x75, 0x6E, 0x6D, 0x6F, 0x64, 0x2F, 0x6D, 0x6F, 0x64, 0x73, 0x2F, 0x68, 0x65, 0x6C, 0x6C, 0x6F, 0x77, 0x6F, 0x72, 0x6C, 0x64, 0x2F, 0x6D, 0x6F, 0x64, 0x2E, 0x6A, 0x73, 0x00, 0x74, 0x72, 0x61, 0x63, 0x65, 0x00, 0x00, 0x00, 0x00, 0x8E, 0x4D, 0x4F, 0x44, 0x53, 0x00, 0x00, 0x00, 0x10, 0x50, 0x41, 0x54, 0x48, 0x6D, 0x6F, 0x64, 0x2E, 0x78, 0x73, 0x62, 0x00, 0x00, 0x00, 0x00, 0x76, 0x43, 0x4F, 0x44, 0x45, 0x4A, 0x01, 0x80, 0x6B, 0x0F, 0x00, 0x4E, 0x01, 0x80, 0x2B, 0x5C, 0x0C, 0x00, 0x89, 0x02, 0x4A, 0x01, 0x80, 0x6B, 0x0F, 0x00, 0xAB, 0x0D, 0x68, 0x65, 0x6C, 0x6C, 0x6F, 0x20, 0x77, 0x6F, 0x72, 0x6C, 0x64, 0x0A, 0x00, 0x60, 0x01, 0xBC, 0x80, 0x02, 0x80, 0x59, 0x02, 0x80, 0x21, 0x7E, 0x6B, 0x11, 0x00, 0x75, 0x00, 0x80, 0x60, 0x00, 0x69, 0x02, 0x7E, 0x87, 0x02, 0x52, 0x02, 0x60, 0x0A, 0x65, 0x18, 0x21, 0x6B, 0x12, 0x00, 0x52, 0x02, 0xAB, 0x02, 0x0A, 0x00, 0x60, 0x02, 0xBC, 0x80, 0x02, 0x80, 0x59, 0x02, 0x80, 0x21, 0x7E, 0x87, 0x02, 0x6B, 0x11, 0x00, 0x52, 0x02, 0x5D, 0x98, 0x02, 0x7E, 0x15, 0xD8, 0xBE, 0x01, 0x3D, 0x41, 0x7E, 0x60, 0x01, 0x6D, 0x8F, 0x3D, 0x00, 0x00, 0x00, 0x08, 0x52, 0x53, 0x52, 0x43).buffer;

const xsb = new XsbugConnection("ws://runmod.local:8080");
xsb.onLogin = function(msg) {
	this.doSetAllBreakpoints([{path: "/Users/hoddie/Projects/moddable/examples/network/websocket/websocketserver/main.js", line: 51}]);
	this.doStep();

	this.doGetPreference("config", "when", function(id, code, data) {
		if (code) {
			console.log("can't get config/when pref");
			return;
		}
		let result = "";
		data = new Uint8Array(data);
		for (let i = 0; i < data.byteLength - 1; i++)
			result += String.fromCharCode(data[i]);
		console.log(`config/when pref is "${result}"`);
	});

	setTimeout(function() {
		xsb.doInstall(0, helloWorldXSA);
		xsb.doRestart();
	}, 5 * 1000);
}
xsb.onBreak = function(msg) {
	this.doGo();
}
